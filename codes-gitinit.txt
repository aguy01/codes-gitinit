git init
git status
git add .
git commit -m "Codes added"
git remote add origin https://github.com/aguy01/codes-gitinit.git
git push origin master

//Print all  integers in  in reverse order as a single line of space-separated integers.
public class Area {
    public static void main(String[] args) {
        ArrayList<Integer> alist = new ArrayList<>();
        Integer numtolist = 0, listsize = 0;
        Scanner in = new Scanner(System.in);
        listsize = in.nextInt();

        for (int i = 0; i < listsize; i++) {

            numtolist = in.nextInt();
            alist.add(numtolist);
        }

        for (int i = alist.size()-1; i >=0; i--) {
            System.out.print(alist.get(i)+" ");

        }
    }}

if(true)
	if something.equals("hi"){return true}
return false

ArrayList: Write a static method to find the sum of all the even numbers in a list. Within main, create a list with at least 10 integers and call your method on the list.

&& and; || or; ! not

public String doubleChar(String str){
String result="";
for (int i =0; i<str.length();i++)
result+=str.substring(

int catcount=0;
int dogcount=0;
if (strr.length()>=3){for (int i=0; i<=str.length()-3;i++){if (str.substring(i,i+3).equals("cat")
catcount++;
else if(str.substring(i,i+3).equals("dog")
dogcount++}}return catcount==dogcount


char count.
Map<Character,Integer) countMap=new HashMap<>();
Character[] charray = myString.toCharArray();

for(character c: charray){

if(countMap.containsKey(c)))
int count = countMap.get(c)
countMap.put(c, ++count);
}
else {countMap.put(c, (Integer)count)
}
}
  for (Map.Entry<String, Integer> charkey : charcount.entrySet()) {
            System.out.println(charkey.getKey() + " (" + charkey.getValue() + ")");



codingbat java.
public boolean prefixAgain(String str, int n) {
return str.substring(n).indexf(Str.substring(0,n))!=-1;
}


Given an array of ints, return true if the array contains no 1's and no 3's.

 public boolean has22(int[] nums) {
  



}


-------------jobsData.java
package org.launchcode.techjobs.console;

import org.apache.commons.csv.CSVFormat;
import org.apache.commons.csv.CSVParser;
import org.apache.commons.csv.CSVRecord;

import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map;//added by me
import java.util.List;
import java.io.*;
import java.util.*;

import static jdk.nashorn.internal.objects.NativeString.toLowerCase;


/**
 * Created by 
 */
public class JobData {

    private static final String DATA_FILE = "resources/job_data.csv";
    private static Boolean isDataLoaded = false;

    private static ArrayList<HashMap<String, String>> allJobs;

    /**
     * Fetch list of all values from loaded data,
     * without duplicates, for a given column.
     *
     * @param field The column to retrieve values from
     * @return List of all of the values of the given field
     */
    public static ArrayList<String> findAll(String field) {//if (actionChoice.equals("list"). if (columnChoice.equals("all"))

        // load data, if not already loaded
        loadData();

        ArrayList<String> values = new ArrayList<>();

        for (HashMap<String, String> row : allJobs) {
            String aValue = row.get(field);//iterate over each row on the same coloumn field.

            if (!toLowerCase(values).contains(toLowerCase(aValue)))/*no duplicates and the list isnt empty for option 4-Skill under List*/  {
                values.add(aValue);

            }
        }
        System.out.println("exit from jobdata->method class ArrayList<String> findAll(String field) and the field passed in is: "+field);

        return values;
    }

    public static ArrayList<HashMap<String, String>> findAll() {//nothin in the argument. this task is complete.

        // load data, if not already loaded
        loadData();
        System.out.println("exit from jobdata->method  ArrayList<HashMap<String, String>> findAll(). works for 0-All option.");
        return allJobs;
    }
    /**
     * Returns results of search the jobs data by key/value, using
     * inclusion of the search term.
     *
     * For example, searching for employer "Enterprise" will include results
     * with "Enterprise Holdings, Inc".
     *
     * @param column   Column that should be searched.
     * @param value Value of teh field to search for
     * @return List of all jobs matching the criteria
     */
    public static ArrayList<HashMap<String, String>> findByColumnAndValue(String column, String value) {

        // load data, if not already loaded
        loadData();

        ArrayList<HashMap<String, String>> jobs = new ArrayList<>();

        for (HashMap<String, String> row : allJobs) {//alljobs is of this type---->>>ArrayList<HashMap<String, String>>.

            String aValue = row.get(column); //in the row get the column passed in assigned to the aValue-which is the column itself.

            if (toLowerCase(aValue).contains(toLowerCase(value))) {//if aValue is in the row+column intersect cell of that column then ok to add to jobs arraylist
                 jobs.add(row);
            }
        }
        System.out.println("passed in column "+column+" and  value "+value+" into the method");
        System.out.println("exit from jobdata->method  ArrayList<HashMap<String, String>> findByColumnAndValue(String column, String value)");
        return jobs;
    }



    /**
     * IMPLEMENT FINDBYVALUE
     *creates a new (public static) method that will search for a string within each of the
     *columns.
     *Returns results of search the jobs data by key/value, using
     * inclusion of the search term.
     *
     * For example, searching for employer "Enterprise" will include results
     * with "Enterprise Holdings, Inc".
     *@param value Value of teh field to search for
     * @return List of all jobs matching the criteria
     */

    public static ArrayList<HashMap<String, String>> findByValue(String value) {

        // load data, if not already loaded
        loadData();

        ArrayList<HashMap<String, String>> jobs = new ArrayList<>();


        for (HashMap<String, String> row : allJobs) {//alljobs is of this type---->>>ArrayList<HashMap<String, String>>.
            //String aValue = row.get(value);
            for (Map.Entry<String, String> subhash : row.entrySet()) {
                //System.out.println(subhash.getKey() + " :" + subhash.getValue() );
                //String aValue = subhash.getValue();
                if (toLowerCase(subhash.getValue()).contains(toLowerCase(value))) {

                    System.out.println("FindByValue-->over 'allJobs' search term value is: "+subhash.getValue());
                    jobs.add(row);
                            }

      //if(!jobs.contains(value))
                   //jobs.add(row);
          //if (allJobs.contains(value)) {
                //jobs.add(row);
                //}
            }
            //System.out.println("passed in value " + value + " into the method ArrayList<HashMap<String, String>> findByValue(String value)");


        }



        return jobs;
    }

    /**
     * Read in data from a CSV file and store it in a list
     */
    private static void loadData() {

        // Only load data once
        if (isDataLoaded) {
            return;
        }

        try {

            // Open the CSV file and set up pull out column header info and records
            Reader in = new FileReader(DATA_FILE);
            CSVParser parser = CSVFormat.RFC4180.withFirstRecordAsHeader().parse(in);
            List<CSVRecord> records = parser.getRecords();
            Integer numberOfColumns = records.get(0).size();
            String[] headers = parser.getHeaderMap().keySet().toArray(new String[numberOfColumns]);

            allJobs = new ArrayList<>();

            // Put the records into a more friendly format
            for (CSVRecord record : records) {
                HashMap<String, String> newJob = new HashMap<>();
                //System.out.println("Hello");

                //System.out.println("first for loop in the loadData, showing record: " + record);//printing added by me.
                for (String headerLabel : headers) {
                    newJob.put(headerLabel, record.get(headerLabel));
                }
                allJobs.add(newJob);

                isDataLoaded = true;

                //int count=0;

            }

        }


            catch (IOException e) {
            System.out.println("Failed to load job data");
            e.printStackTrace();
        }
    }

}
-------------------------
package org.launchcode.techjobs.console;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;
import java.util.Map;
/**
 * Created by 
 */
public class TechJobs {

    private static Scanner in = new Scanner(System.in);

    public static void main (String[] args) {

        // Initialize our field map with key/name pairs
        HashMap<String, String> columnChoices = new HashMap<>();
        columnChoices.put("core competency", "Skill");
        columnChoices.put("employer", "Employer");
        columnChoices.put("location", "Location");
        columnChoices.put("position type", "Position Type");
        columnChoices.put("all", "All");

        // Top-level menu options
        HashMap<String, String> actionChoices = new HashMap<>();
        actionChoices.put("search", "Search");
        actionChoices.put("list", "List");

        System.out.println("Welcome to LaunchCode's TechJobs App!");

        // Allow the user to search until they manually quit
        while (true) {

            String actionChoice = getUserSelection("View jobs by:", actionChoices);

            if (actionChoice.equals("list")) {

                String columnChoice = getUserSelection("List", columnChoices);

                if (columnChoice.equals("all")) {
                    printJobs(JobData.findAll());//done. part of the 1st task tbd. sends the call and activates with 0 from -List->0-All occurs.
                } else {

                    ArrayList<String> results = JobData.findAll(columnChoice);

                    System.out.println("\n*** All " + columnChoices.get(columnChoice) + " Values ***");

                    // Print list of skills, employers, etc
                    for (String item : results) {
                        System.out.println(item);
                    }
                }

            } else { // choice is "search"

                // How does the user want to search (e.g. by skill or employer)
                String searchField = getUserSelection("Search by:", columnChoices);

                // What is their search term?
                System.out.println("\nSearch term: ");
                String searchTerm = in.nextLine();

                if (searchField.equals("all")) {
                    printJobs(JobData.findByValue(searchTerm));
                    System.out.println("coming from main-->Search all fields in progress.");
                } else {
                    printJobs(JobData.findByColumnAndValue(searchField, searchTerm));
                }
            }
        }
    }

    // ?Returns the key of the selected item from the choices Dictionary
    private static String getUserSelection(String menuHeader, HashMap<String, String> choices) {

        Integer choiceIdx;
        Boolean validChoice = false;
        String[] choiceKeys = new String[choices.size()];

        // Put the choices in an ordered structure so we can
        // associate an integer with each one
        Integer i = 0;
        for (String choiceKey : choices.keySet()) {
            choiceKeys[i] = choiceKey;
            //System.out.println("choice keys are:"+choiceKeys[i]);
            i++;
        }

        do {

            System.out.println("\n" + menuHeader);

            // Print available choices
            for (Integer j = 0; j < choiceKeys.length; j++) {
                System.out.println("" + j + " -" + choices.get(choiceKeys[j]));
            }

            choiceIdx = in.nextInt();
            in.nextLine();

            // Validate user's input
            if (choiceIdx < 0 || choiceIdx >= choiceKeys.length) {
                System.out.println("Invalid choice. Try again.");
            } else {
                validChoice = true;
            }

        } while(!validChoice);

        return choiceKeys[choiceIdx];
    }

    // Print a list of jobs
    private static void printJobs(ArrayList<HashMap<String, String>> someJobs) {//somejobs is of type arraylist<<hashmap>>
        //i added use this ------>>>>>> public static ArrayList<HashMap<String, String>> findAll()
        Boolean choice1 = false;

       // ArrayList<HashMap<String, String>> printalljobs   = new ArrayList<>();
        //printalljobs=someJobs;
        //HashMap<String, String> newjob1 = new HashMap<>();
        //String []

            int count=1;
        for (HashMap<String, String> hash : someJobs){
            choice1=true;
                {//System.out.println(hash.keySet()+" <-key,values-> "+hash.values()+"hash size is: "+hash.size());
                    System.out.println("Job list# "+count++);
                    System.out.println("**********");
                    for (Map.Entry<String, String> subhash : hash.entrySet()) {
                        System.out.println(subhash.getKey() + " :" + subhash.getValue() );
                    }
                    System.out.println("**********\n");
                }

        }
        if (choice1=true)
            System.out.println("\n##################");
            System.out.println(((int)count-1)+" Job listings found");
            System.out.println("##################");

        if (choice1=false)
            System.out.println("Search yields no result. Please try again. printJobs is not done!");
    }
}


-------------------
public class BankAccount {

private String firstName;
private String lastName;
private double balance;
private int acctNumber;
private static int nextAvailableAcctNumber =1;

0 references
public BankAccount(String firstName, String lastName, double initialBalance){

	this.firstName=firstName;
	this.lastName=lastname;
	this.balance=initialBalance;
	this.acctNumber=nextAvailableAcctNumber++;

}

0 references

 public void depost(double value)
{	this.balance +=value

}

pubic String getFirstName(){
	return this.firstName;


}

0 references

pubic String getLastName(){
	return this.lastName;


}


public double getBalance() {
return this.balance

}




}


--------------------------
public class BankAccountTester{
public static void main (String[] args)
{
BankAccount ba1=new BankAccount("Matt","Orbet",5000.00)

BankAccount ba2=new BankAccount("Rebecca","Wagman",6000.00)
